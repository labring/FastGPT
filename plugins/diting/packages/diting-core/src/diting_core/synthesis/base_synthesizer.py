#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from abc import ABC, abstractmethod
from typing import Any, List, Optional

from diting_core.callbacks.manager import new_group
from diting_core.cases.llm_case import LLMCase
from diting_core.utilities.slug import camel_to_snake
from diting_core.utilities.validate import assert_fields_validity
from diting_core.models.llms.base_model import BaseLLM
from diting_core.synthesis.base_corpus import BaseCorpus


class BaseSynthesizer(ABC):
    """
    Abstract base class for data synthetic in diting.

    Attributes:
        required_input_fields (List[str]): The list of input fields required for the Synthesizer.
        required_output_fields (List[str]): The list of output fields expected from the Synthesizer.
    """

    def __init__(self, model: Optional[BaseLLM] = None):
        self.model = model

    required_output_fields: List[str] = []
    required_input_fields: List[str] = []

    async def apply(self, corpus: BaseCorpus, **kwargs: Any) -> LLMCase:
        """Applies the generation Synthesizer to the provided input data.

        This method manages the execution of the Synthesizer, including input validation,
        callback management, and error handling. It ensures that the required input
        fields are present and that the output fields are valid.

        Args:
            corpus (BaseCorpus): The input data for the Synthesizer, which must contain
                the required fields specified in `required_input_fields`.
            **kwargs (Any): Additional keyword arguments that may include:
                - callbacks: A list of callback functions to be executed during the Synthesizer application.
                - verbose: A boolean indicating whether to enable verbose logging.

        Returns:
            LLMCase: The output data generated by applying the Synthesizer, which must
            contain the required fields specified in `required_output_fields`.

        Raises:
            Exception: If there is an error during the Synthesizer application or if the input
            or output validation fails.
        """
        from diting_core.callbacks.base import ChainType

        run_manager, grp_cb = await new_group(
            name=self.name,
            inputs={"corpus": corpus},
            callbacks=kwargs.pop("callbacks", None),
            verbose=kwargs.pop("verbose", False),
            chain_type=ChainType.SYNTHETIC,
            required_input_fields=self.required_input_fields,
            required_output_fields=self.required_output_fields,
        )
        try:
            assert_fields_validity(self.name, corpus, self.required_input_fields)
            llm_case = await self._apply(corpus, callbacks=grp_cb, **kwargs)
            assert_fields_validity(self.name, llm_case, self.required_output_fields)
        except Exception as e:
            await run_manager.on_chain_error(e)
            raise e
        await run_manager.on_chain_end({"llm_case": llm_case})
        return llm_case

    @abstractmethod
    async def _apply(self, corpus: BaseCorpus, **kwargs: Any) -> LLMCase:
        raise NotImplementedError

    @property
    def name(self) -> str:
        return camel_to_snake(self.__class__.__name__)
